<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一次作业总结报告</title>
      <link href="/2024/04/16/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/04/16/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="博客主题及其选取原因"><a href="#博客主题及其选取原因" class="headerlink" title="博客主题及其选取原因"></a>博客主题及其选取原因</h1><ul><li>博客框架<ul><li>Hexo</li></ul></li><li>框架选取原因<ol><li><strong>静态站点生成器</strong>：Hexo 是一个快速、简洁且高效的静态站点生成器，它允许用户使用 Markdown 编写文章，然后一键生成静态页面。这种生成静态页面的方式有利于提高网站的加载速度，同时也减轻了服务器的负担。</li><li><strong>易于部署</strong>：Hexo 生成的静态文件可以轻松部署到 GitHub Pages、Netlify、Vercel 等平台上，这些平台提供了免费的托管服务，对于个人博客来说是一个经济实惠的选择。</li><li><strong>插件丰富</strong>：Hexo 拥有丰富的插件生态系统，用户可以根据自己的需求选择合适的插件来扩展博客的功能，如搜索、评论、统计等。</li><li><strong>主题多样</strong>：Hexo 社区提供了大量的主题供用户选择，这些主题风格多样，可以满足不同用户的审美需求。同时，这些主题通常都具有良好的文档支持和可定制性，用户可以根据自己的喜好进行个性化设置。</li><li><strong>简单易用</strong>：Hexo 的操作相对简单，对于没有编程背景的用户来说也能够快速上手。它的命令行工具使得编写、管理和发布文章变得非常方便。</li><li><strong>社区支持</strong>：Hexo 拥有一个活跃的社区，用户在遇到问题时可以很容易地找到帮助和解决方案。社区成员经常分享经验、教程和最佳实践，这对于新用户来说是一个宝贵的资源。</li><li><strong>灵活性</strong>：Hexo 允许用户自定义页面布局和样式，支持自定义 permalinks、分类和标签等，用户可以根据自己的需求对博客进行灵活配置。</li><li><strong>性能优化</strong>：Hexo 支持生成文件的压缩和最小化，可以优化网站的加载速度，提高用户体验</li></ol></li><li>主题<ul><li>Butterfly</li></ul></li><li>主题选取原因<ol><li><strong>美观性</strong>：Butterfly 主题以其简洁、清新的设计风格吸引了我的注意。它的色彩搭配和布局设计都符合现代网页设计的审美趋势，能够给访问者带来良好的视觉体验。</li><li><strong>响应式设计</strong>：随着移动设备的普及，响应式网页设计变得尤为重要。Butterfly 主题能够自动适应不同大小的屏幕，保证了移动端用户的浏览体验。</li><li><strong>丰富的功能</strong>：Butterfly 主题提供了丰富的插件和扩展功能，如评论系统、搜索功能、文章分类和标签云等，这些功能能够满足我对于一个个人博客网站的基本需求。</li><li><strong>活跃的社区支持</strong>：Butterfly 主题有着活跃的社区支持，这意味着在使用过程中遇到的问题可以得到及时的帮助和解决。</li><li><strong>易定制性</strong>：作为一个对网页设计有一定了解的用户，我希望能够根据自己的喜好对博客进行个性化定制。Butterfly 主题提供了详细的文档和大量的自定义选项，使得定制过程变得简单可行。</li></ol></li></ul><h1 id="博客页面布局及其设计思路"><a href="#博客页面布局及其设计思路" class="headerlink" title="博客页面布局及其设计思路"></a>博客页面布局及其设计思路</h1><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><ul><li>头部：包含博客标题、导航栏和搜索框，方便用户快速导航和搜索内容。</li><li>正文区：展示最新的博客文章列表，每篇文章包括标题、摘要、发布日期和阅读量等信息。</li><li>侧边栏：包括作者信息、文章分类、标签云、热门文章和友情链接等，为用户提供更多相关信息和便捷的访问途径。</li><li>底部：包含版权信息、联系方式和返回顶部按钮，增加网站的完整性和用户友好性。</li></ul><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ul><li>用户导向：在设计过程中，始终将用户体验放在首位，确保网站的功能布局和内容展示都能满足用户的需求。</li><li>简洁明了：避免页面过于杂乱，通过清晰的布局和适量的留白，让用户能够快速找到他们感兴趣的内容。<br>视觉统一：保持页面元素的视觉风格一致性，使用统一的字体、颜色和图标，增强页面的整体感。</li><li>交互流畅：确保页面的响应速度和交互流畅性，减少用户的等待时间，提升用户体验。</li></ul><h1 id="博客功能实现及其技术选择"><a href="#博客功能实现及其技术选择" class="headerlink" title="博客功能实现及其技术选择"></a>博客功能实现及其技术选择</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ul><li>文章发布与管理：使用 Markdown 语法编写文章，通过 Hexo 的命令行工具生成静态页面。</li><li>搜索功能：通过 Hexo 的搜索插件实现站内文章的搜索功能。</li><li>文章分类与标签：利用 Hexo 的分类和标签功能，对文章进行分类和标记，方便用户查找相关内容。</li></ul><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><ul><li>Hexo：作为一个快速、简洁且高效的博客框架，Hexo 允许用户使用 Markdown 编写文章，一键生成静态页面，非常适合静态博客网站的建设。</li><li>Butterfly 主题：基于 Hexo 的 Butterfly 主题，提供了丰富的功能和高度的可定制性，使得博客的建设更加简单和高效。</li><li>Markdown：作为一种轻量级标记语言，Markdown 使得文章的编写变得更加简单和直观，同时保证了文章在不同平台上的兼容性。</li></ul><h1 id="博客制作过程中遇到的问题及其解决方法"><a href="#博客制作过程中遇到的问题及其解决方法" class="headerlink" title="博客制作过程中遇到的问题及其解决方法"></a>博客制作过程中遇到的问题及其解决方法</h1><h2 id="问题1：不知道如何启动Hexo框架的开发流程以及启动流程"><a href="#问题1：不知道如何启动Hexo框架的开发流程以及启动流程" class="headerlink" title="问题1：不知道如何启动Hexo框架的开发流程以及启动流程"></a>问题1：不知道如何启动Hexo框架的开发流程以及启动流程</h2><p>通过搜索引擎+ChatGPT对话模型完成了相关信息的获取，并通过本地实验尝试。</p><h2 id="问题2：开启Butterfly主题的导航栏功能后，对应菜单点击后跳出的是错误页面。"><a href="#问题2：开启Butterfly主题的导航栏功能后，对应菜单点击后跳出的是错误页面。" class="headerlink" title="问题2：开启Butterfly主题的导航栏功能后，对应菜单点击后跳出的是错误页面。"></a>问题2：开启Butterfly主题的导航栏功能后，对应菜单点击后跳出的是错误页面。</h2><p>通过ChatGPT了解到，需要先通过hexo新建page。然后通过设置page的type为对应的菜单tag，这样就可以<br>将菜单与page关联上。</p>]]></content>
      
      
      <categories>
          
          <category> 开源社区课程作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvim学习笔记</title>
      <link href="/2024/04/16/nvim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/16/nvim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>j k h l</td><td>下 上 左 右</td></tr><tr><td><code>ESC</code> + u</td><td>undo the last change</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 学习笔记</title>
      <link href="/2024/04/16/shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/16/shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><blockquote><p>What is the shell</p></blockquote><p>The shell is a programming environment, just like Python or Ruby, and so it has variables, conditionals, loops, and functions.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo $PATH</span><br><span class="line">missing:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ which echo</span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><p>We can find out which file is executed for a given program name using the &#x3D;&#x3D;which&#x3D;&#x3D; program. We can also bypass $PATH entirely by giving the path to the file we want to execute.</p><blockquote><p>Connecting programs</p></blockquote><p>The simplest form of redirection is &lt; file and &gt; file. These let you rewire the input and output streams of a program to a file respectively:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello &gt; hello.txt</span><br><span class="line">missing:~$ cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;cat&#x3D;&#x3D; is a program that concatenates files. When given file names as arguments, it prints the contents of each of the files in sequence to its output stream</p><p>You can also use &#x3D;&#x3D;&gt;&gt;&#x3D;&#x3D; to append to a file. Where this kind of input&#x2F;output redirection really shines is in the use of pipes. The &#x3D;&#x3D;|&#x3D;&#x3D; operator lets you “chain” programs such that the output of one is the input of another:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls -l / | tail -n1</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219</span><br></pre></td></tr></table></figure><blockquote><p>A versatile and powerful tool</p></blockquote><ul><li>sudo<br>As its name implies, it lets you “do” something “as su” (short for “super user”, or “root”),example:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 | sudo <span class="built_in">tee</span> brightness</span></span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="Shell-Script"><a href="#Shell-Script" class="headerlink" title="Shell Script"></a>Shell Script</h1><blockquote><p>variables ans functions</p></blockquote><p>To assign variables in bash, use the syntax <code>foo=bar</code> and access the value of the variable with <code>$foo</code>. Note that <code>foo = bar</code> will not work since it is interpreted as calling the foo program with arguments <code>=</code> and <code>bar</code><br>Strings in bash can be defined with <code>&#39;</code> and <code>&quot;</code> delimiters, but they are not equivalent. Strings delimited with <code>&#39;</code> are literal strings and will not substitute variable values whereas <code>&quot; </code>delimited strings will.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line">echo &quot;$foo&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prints bar</span></span><br><span class="line">echo &#x27;$foo&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prints <span class="variable">$foo</span></span></span><br></pre></td></tr></table></figure><p>As with most programming languages, bash supports control flow techniques including <code>if</code>, <code>case</code>, <code>while</code> and <code>for</code>. Similarly, bash has functions that take arguments and can operate with them. Here is an example of a function that creates a directory and <code>cd</code> into it.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p &quot;$1&quot;</span><br><span class="line">    cd &quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>special variables</p></blockquote><p>Here $1 is the first argument to the script&#x2F;function. Unlike other scripting languages, bash uses a variety of special variables to refer to arguments, error codes, and other relevant variables. Below is a list of some of them. A more comprehensive list can be found <a href="https://tldp.org/LDP/abs/html/special-chars.html">here</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$0 - Name of the script</span><br><span class="line">$1 to $9 - Arguments to the script. $1 is the first argument and so on.</span><br><span class="line">$@ - All the arguments</span><br><span class="line">$# - Number of arguments</span><br><span class="line">$? - Return code of the previous command</span><br><span class="line">$$ - Process identification number (PID) for the current script</span><br><span class="line">!! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing sudo !!</span><br><span class="line">$_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . or Alt+.</span><br></pre></td></tr></table></figure><p>Commands will often return output using <code>STDOUT</code>, errors through <code>STDERR</code>, and a Return Code to report errors in a more script-friendly manner. The return code or exit status is the way scripts&#x2F;commands have to communicate how execution went. A value of 0 usually means everything went OK; anything different from 0 means an error occurred.</p><blockquote><p>Exit codes can be used to conditionally</p></blockquote><p>Exit codes can be used to conditionally execute commands using <code>&amp;&amp;</code> (and operator) and <code>||</code> (or operator), both of which are short-circuiting operators. Commands can also be separated within the same line using a semicolon <code>;</code> The <code>true</code> program will always have a 0 return code and the <code>false</code> command will always have a 1 return code. Let’s see some examples</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">false || echo &quot;Oops, fail&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Oops, fail</span></span><br><span class="line"></span><br><span class="line">true || echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true &amp;&amp; echo &quot;Things went well&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Things went well</span></span><br><span class="line"></span><br><span class="line">false &amp;&amp; echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true ; echo &quot;This will always run&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br><span class="line"></span><br><span class="line">false ; echo &quot;This will always run&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br></pre></td></tr></table></figure><p>Another common pattern is wanting to get the output of a command as a variable. This can be done with command substitution. Whenever you place <code>$( CMD )</code> it will execute <code>CMD</code>, get the output of the command and substitute it in place. For example, if you do <code>for file in $(ls)</code>, the shell will first call <code>ls</code> and then iterate over those values.<br>A lesser known similar feature is process substitution, <code>&lt;( CMD )</code> will execute <code>CMD</code> and place the output in a temporary file and substitute the <code>&lt;()</code> with that file’s name. This is useful when commands expect values to be passed by file instead of by <code>STDIN</code>. For example,<code> diff &lt;(ls foo) &lt;(ls bar)</code> will show differences between files in dirs <code>foo</code> and <code>bar</code>.<br>let’s see an &#x3D;&#x3D;example&#x3D;&#x3D; that showcases some of these features. It will iterate through the arguments we provide, grep for the string foobar, and append it to the file as a comment if it’s not found:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # Date will be substituted</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in &quot;$@&quot;; do</span><br><span class="line">    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # When pattern is not found, grep has exit status 1</span><br><span class="line">    # We redirect STDOUT and STDERR to a null register since we do not care about them</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>[[ ]]</code> is one sort of comparation. see <a href="http://mywiki.wooledge.org/BashFAQ/031">test</a> to learn detail.</p><blockquote><p>shell globbing</p></blockquote><ul><li><p>Wildcards - Whenever you want to perform some sort of wildcard matching, you can use <code>?</code> and <code>*</code> to match one or any amount of characters respectively. For instance, given files <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> and <code>bar</code>, the command <code>rm foo?</code> will delete <code>foo1</code> and <code>foo2</code> whereas <code>rm foo*</code> will delete all but bar.</p></li><li><p>Curly braces <code>&#123;&#125;</code> - Whenever you have a common substring in a series of commands, you can use curly braces for bash to expand this automatically. This comes in very handy when moving or converting files.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Will <span class="built_in">expand</span> to</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line">cp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Will <span class="built_in">expand</span> to</span></span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Globbing techniques can also be combined</span></span><br><span class="line">mv *&#123;.py,.sh&#125; folder</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Will move all *.py and *.sh files</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h</span></span><br><span class="line">touch &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line">touch foo/x bar/y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Show differences between files <span class="keyword">in</span> foo and bar</span></span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Outputs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt; y</span></span><br></pre></td></tr></table></figure><blockquote><p>Some differences between shell functions and scripts</p></blockquote></li><li><p>Functions have to be in the same language as the shell, while scripts can be written in any language. This is why including a shebang for scripts is important.</p></li><li><p>Functions are loaded once when their definition is read. Scripts are loaded every time they are executed. This makes functions slightly faster to load, but whenever you change them you will have to reload their definition.</p></li><li><p>Functions are executed in the current shell environment whereas scripts execute in their own process. Thus, functions can modify environment variables, e.g. change your current directory, whereas scripts can’t. Scripts will be passed by value environment variables that have been exported using <code>export</code></p></li><li><p>As with any programming language, functions are a powerful construct to achieve modularity, code reuse, and clarity of shell code. Often shell scripts will include their own function definitions.</p></li></ul><blockquote><p>Finding how to use commands</p></blockquote><ol><li><code>-h</code> or <code>--help</code>: said command</li><li><code>man</code>: more detail</li><li><code>tldr</code>: example of use case</li></ol><blockquote><p>Finding files</p></blockquote><ul><li><p><code>find</code><br>All UNIX-like systems come packaged with <code>find</code>, a great shell tool to find files. <code>find</code> will recursively search for files matching some criteria. Some examples:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all directories named src</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all python files that have a folder named <span class="built_in">test</span> <span class="keyword">in</span> their path</span></span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all files modified <span class="keyword">in</span> the last day</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all zip files with size <span class="keyword">in</span> range 500k to 10M</span></span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure><p>Beyond listing files, <code>find</code> can also perform actions over files that match your query. This property can be incredibly helpful to simplify what could be fairly monotonous tasks.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Delete all files with .tmp extension</span></span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all PNG files and convert them to JPG</span></span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure></li><li><p><code>fd</code><br>fd is a simple, fast, and user-friendly alternative to find. It offers some nice defaults like colorized output, default regex matching, and Unicode support. It also has, in my opinion, a more intuitive syntax. For example, the syntax to find a pattern <code>PATTERN</code> is <code>fd PATTERN</code>.</p></li><li><p><code>locate</code><br>more effcient, and just uses file name. The difference bettwen <code>locate</code> and <code>find</code> are <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a></p></li></ul><blockquote><p>search based on file content</p></blockquote><ul><li>grep</li><li>ripgrep(rg)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all python files <span class="built_in">where</span> I used the requests library</span></span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all files (including hidden files) without a shebang line</span></span><br><span class="line">rg -u --files-without-match &quot;^#\!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find all matches of foo and <span class="built_in">print</span> the following 5 lines</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Print statistics of matches (<span class="comment"># of matched lines and files )</span></span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda笔记</title>
      <link href="/2024/04/15/conda-prompt/"/>
      <url>/2024/04/15/conda-prompt/</url>
      
        <content type="html"><![CDATA[<p>新建环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n (环境名) python=（指定的python版本）</span><br></pre></td></tr></table></figure><p>删除环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完全删除环境</span></span><br><span class="line">conda remove -n (环境名) -all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除环境的某个包</span></span><br><span class="line">conda remove -n (环境名) （包名）</span><br></pre></td></tr></table></figure><p>进入环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate (环境名)</span><br></pre></td></tr></table></figure><p>退出环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>查看有所有环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --env</span><br></pre></td></tr></table></figure><p>查看该环境的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到某环境后</span></span><br><span class="line">conda info</span><br></pre></td></tr></table></figure><p>查看所有源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config -show channels</span><br></pre></td></tr></table></figure><p>查看环境中有哪些包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
